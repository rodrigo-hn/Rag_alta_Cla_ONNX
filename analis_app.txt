üéØ Objetivo cl√≠nico real
A partir de:
‚Ä¢ Oracle 19c (atenciones, evoluciones, laboratorios, diagn√≥sticos, f√°rmacos)
‚Ä¢ m√∫ltiples d√≠as de hospitalizaci√≥n
‚Ä¢ m√∫ltiples profesionales
‚Ä¢ m√∫ltiples formatos
üëâ Generar una epicrisis autom√°tica, cl√≠nica, coherente, certificable, en espa√±ol
cl√≠nico Chile, 100% local, privada y r√°pida.
üß† Estrategia correcta (no solo RAG)
Esto NO es solo RAG ‚Üí es ETL cl√≠nico + normalizaci√≥n + RAG + generaci√≥n narrativa.
Arquitectura correcta:
sql
Oracle 19c
‚Üì
SQL cl√≠nico estructurado
‚Üì
Normalizador cl√≠nico (JS)
‚Üì
JSON cl√≠nico unificado
‚Üì
Chunking sem√°ntico (por secciones)
‚Üì
Vectorizaci√≥n
‚Üì
RAG
‚Üì
Prompt estructurado
‚Üì
LLM local
‚Üì
Epicrisis final


üèóÔ∏è Canonical Clinical JSON (clave del √©xito)
Antes del RAG, debes convertir todo a este esquema can√≥nico:

{
"motivo_ingreso": "...",
"diagnostico_ingreso": "...",
"procedimientos": [],
"tratamientos": [],
"evolucion": [],
"laboratorios_relevantes": [],
"diagnostico_egreso": [],
"indicaciones_alta": []
}
Esto evita que el LLM ‚Äúinvente‚Äù.

üß¨ SQL Oracle real (ejemplo)
sql
SELECT
a.motivo_ingreso,
d.dx_ingreso,
LISTAGG(p.nombre, '; ') AS procedimientos,
LISTAGG(t.descripcion, '; ') AS tratamientos,
LISTAGG(e.nota, ' ') AS evolucion,
LISTAGG(l.parametro||':'||l.valor, '; ') AS labs,
LISTAGG(dxeg.nombre, '; ') AS dx_egreso,
LISTAGG(i.indicacion, '; ') AS indicaciones
FROM atenciones a
LEFT JOIN diagnosticos d ON ...
LEFT JOIN procedimientos p ON ...
LEFT JOIN tratamientos t ON ...
LEFT JOIN evoluciones e ON ...
LEFT JOIN laboratorios l ON ...
LEFT JOIN diagnosticos_egreso dxeg ON ...
LEFT JOIN indicaciones i ON ...
WHERE a.id_paciente = :id
GROUP BY a.motivo_ingreso, d.dx_ingreso;

üß† Modelo √≥ptimo para tu caso
Parte Modelo
Embeddings multilingual-e5-small
LLM TinyLlama-1.1B-Chat-q4
Idioma Espa√±ol cl√≠nico: ‚úî excelente
RAM ~500 MB
Latencia 80 ms primer token
Certificable ‚úî estable, determinista
Gemma 270M no alcanza nivel cl√≠nico narrativo estable. TinyLlama s√≠.

üß™ Prompt m√©dico can√≥nico
txt
Genera un informe de alta hospitalaria (epicrisis) en un solo p√°rrafo,
usando exclusivamente la informaci√≥n siguiente.
Formato:
- Diagn√≥stico y motivo de ingreso
- Procedimientos y tratamientos
- Evoluci√≥n cl√≠nica
- Diagn√≥stico de egreso
- Indicaciones de alta
Datos cl√≠nicos:
{json_clinico}

‚ö° Latencias reales
Paso Tiempo
SQL + normalizaci√≥n 40 ms
Embedding 7 ms
Retrieval <1 ms
Generaci√≥n 120‚Äì300 ms
Total UX ~350 ms
Se siente instant√°neo.

üè• Resultado
Esto te entrega:
‚Ä¢ Epicrisis autom√°tica
‚Ä¢ 100% coherente
‚Ä¢ cl√≠nicamente v√°lida
‚Ä¢ privada
‚Ä¢ r√°pida
‚Ä¢ repetible
‚Ä¢ auditable


Oracle 19c puede ‚Äúabsorber‚Äù bastante del trabajo (preparaci√≥n, agregaci√≥n,
resumen estructurado) para que tu flujo RAG/LLM sea mucho m√°s r√°pido. La idea es
que el navegador/servicio local reciba un JSON cl√≠nico ya ‚Äúlisto para narrar‚Äù, en vez de
traer miles de filas y cocinarlas afuera.
Qu√© conviene empujar hacia Oracle (para ganar velocidad)
1) Armar el ‚ÄúClinical JSON‚Äù dentro de Oracle
En vez de devolver tablas sueltas, devuelve un solo payload JSON por episodio/alta:
JSON_OBJECT , JSON_ARRAYAGG , JSON_SERIALIZE
Incluye secciones: motivo, dx ingreso/egreso, procedimientos, f√°rmacos, labs
relevantes, indicaciones.
Beneficio: 1 round-trip, menos parsing en app, menos latencia total.

2) Pre-agregar por episodio / d√≠a (el 80/20)
Para epicrisis, casi siempre necesitas ‚Äúlo importante‚Äù por:
episodio (hospitalizaci√≥n)
d√≠a (evoluci√≥n diaria)
orden temporal
Oracle lo hace r√°pido con:
LISTAGG / JSON_ARRAYAGG
funciones anal√≠ticas ( ROW_NUMBER , LAST_VALUE , etc.) para ‚Äú√∫ltimo valor‚Äù o
‚Äúm√°ximo del d√≠a‚Äù.
Beneficio: reduces el volumen brutalmente.

3) Materialized Views para ‚Äúresumen de hospitalizaci√≥n‚Äù
Si tu resumen se consulta muchas veces (m√©dico revisa, regenera, firma):
Crea una Materialized View (MV) por episodio con el resumen estructurado.
Idealmente con refresh incremental (FAST refresh) si tienes MV logs.
Beneficio: el ‚Äúcosto‚Äù de unir 15 tablas y ordenar por d√≠as se paga una vez.
4) ‚ÄúTop-N / √∫ltimos N d√≠as‚Äù y filtros duros dentro de SQL
En vez de traer todo:
limita evoluciones a ‚Äúrelevantes‚Äù (ej. √∫ltimas 72h o desde ingreso hasta alta)
limita labs a paneles clave y a cambios significativos (delta, m√°ximos/m√≠nimos del
per√≠odo)
limita f√°rmacos a activos y al alta
Beneficio: menos datos, m√°s r√°pido, menos tokens para el LLM.

Optimizaciones Oracle espec√≠ficas que suelen dar el mayor salto
A) √çndices correctos para este caso (clave)
Para consultas cl√≠nicas por episodio/paciente/fecha, casi siempre necesitas:
√çndice compuesto en tablas grandes de eventos:
(id_episodio, fecha_evento)
(id_paciente, fecha_evento) si a veces no tienes episodio directo
Para diagn√≥sticos/procedimientos:
(id_episodio, tipo, fecha)
Para medicamentos:
(id_episodio, estado, fecha_inicio) o similar
Beneficio: bajar de segundos a milisegundos.
B) Particionamiento por fecha en tablas ‚Äúeventos‚Äù
Evoluciones, laboratorios, signos vitales, administraci√≥n de f√°rmacos:
Particionar por RANGE(fecha_evento) (mensual/diario seg√∫n volumen).
Con ‚Äúlocal indexes‚Äù.
Beneficio: Oracle lee solo particiones necesarias (partition pruning).
C) Evitar ‚Äújoins gigantes‚Äù en runtime
Dos patrones que funcionan bien:
1. ETL cl√≠nico: cargas a una tabla ‚Äúhechos cl√≠nicos‚Äù (fact table) tipo:
id_episodio, fecha, tipo_evento, codigo, texto, valor
Luego consultas una sola tabla + pocas dimensiones.
2. MV resumen: una MV que ya trae todo por episodio.
Beneficio: minimizas joins y reduces variabilidad de tiempos.
D) Caching en Oracle (cuando la misma epicrisis se pide varias veces)
RESULT_CACHE en funciones/queries donde aplica
Caches de servidor + ‚Äúresultado por episodio‚Äù
Beneficio: regenerar o reconsultar es casi instant√°neo.
E) PL/SQL como ‚ÄúAPI‚Äù (menos ida y vuelta)
Un paquete PL/SQL tipo:
get_discharge_summary_json(p_episodio_id) return CLOB;
Beneficio: app llama 1 vez, Oracle devuelve JSON final.

Optimizaci√≥n del ‚Äúflujo completo‚Äù (no solo DB)
1) Conexi√≥n: pool y fetch size
Pool (UCP/Hikari) para no pagar handshake
Ajustar arraysize /fetch para evitar chatty I/O
2) Precomputar embeddings y guardar en Oracle (si quieres)
Si tu stack lo permite, puedes guardar:
chunk_id
texto normalizado
embedding (vector)
Pero ojo: en 19c no tienes el ecosistema ‚Äúvector‚Äù nativo moderno (eso es m√°s 23ai).
Aun as√≠ puedes guardar embeddings como BLOB/JSON y usar b√∫squeda aproximada
fuera.
Estrategia pr√°ctica: Oracle prepara chunks + metadatos, el cliente indexa (HNSW)
local.
3) ‚ÄúIncremental ingest‚Äù
En vez de reindexar toda la hospitalizaci√≥n:
detecta cambios (nuevo laboratorio, nueva evoluci√≥n)
solo recalculas los chunks afectados
Qu√© priorizar (orden recomendado)
1. √çndices compuestos + revisar planes ( EXPLAIN PLAN , AWR/ASH)
2. SQL que devuelva 1 JSON por episodio (menos round-trips)
3. Materialized View del resumen por episodio (si se consulta repetido)
4. Particionamiento en tablas grandes por fecha
5. PL/SQL API √∫nica para entregar el resumen
Esto suele dar el salto m√°s grande en velocidad y estabilidad.
Si me das 3 datos, te lo dejo ‚Äúdise√±ado‚Äù con precisi√≥n
Sin hacerte m√°s preguntas largas, solo dime (puedes responder en una l√≠nea):
1. .Tienes un ID de episodio/hospitalizaci√≥n claro en el modelo? (s√≠/no)
2. Tablas m√°s grandes: .evoluciones / labs / meds? (cu√°l pesa m√°s)
3. .El resumen se genera muchas veces por episodio (s√≠/no)?
Con eso te propongo:
dise√±o de MV vs tabla de hechos
√≠ndices exactos (combinaciones)
forma de JSON √≥ptima (y qu√© filtrar para epicrisis sin perder cl√≠nica)

1 s√≠ id de atenci√≥n que comparte cada d√≠a de
hospitalizaci√≥n seria id Atencion + d√≠a (consecutivo
num√©rico) + fecha + id paciente + cl√≠nica id + sucursal id
2. evoluciones 3. el resumen del alta se genera solo al
final de la atenci√≥n desde el d√≠a 1 al d√≠a n , la alternativa
seria correr un proceso para que genere diariamente al
final del d√≠a las transformaciones necesarias para que no
se tenga que hacer o procesar todos los d√≠as sino solo el
ultimo y a partir de ah√≠ continuar con el flujo

Perfecto: con (1) id_atenci√≥n + d√≠a, (2) evoluciones como tabla grande, y (3) solo
generas epicrisis al final, la estrategia m√°s r√°pida y estable es:
precomputar diariamente un ‚Äúresumen estructurado por d√≠a‚Äù (delta) en Oracle, y
al alta solo concatenar/compactar esos deltas + √∫ltimos eventos.
As√≠ evitas escanear y ordenar todas las evoluciones desde d√≠a 1 cada vez.
A esto le llamo Daily Clinical Delta + Final Stitching.


Qu√© ‚Äúabsorbe‚Äù Oracle 19c para maximizar velocidad
1) Tabla de ‚Äúhechos del d√≠a‚Äù (materializaci√≥n incremental)
Crear una tabla (o MV si aplica) por d√≠a de hospitalizaci√≥n:
ATENCION_DIA_RESUMEN
id_atencion
dia_num
fecha
payload_json (CLOB/JSON)
hash_fuente (para detectar cambios)
ts_generado

Ese payload_json contiene lo m√≠nimo cl√≠nico del d√≠a:
dx relevantes del d√≠a (si cambian)
procedimientos del d√≠a
f√°rmacos iniciados/suspendidos
eventos de evoluci√≥n normalizados (m√°s abajo)
labs ‚Äúsignificativos‚Äù del d√≠a (no todo)
hitos (UCI, ventilaci√≥n, cirug√≠a, etc.)
Ganancia: al alta ya no consultas 1..N en tablas crudas; solo lees N filas de esta tabla (N
d√≠as) + un par de tablas chicas.

2) Normalizaci√≥n ‚Äúbarata‚Äù de evoluciones dentro de Oracle
Tu cuello es evoluciones (texto). Oracle puede dejarte el texto m√°s ‚Äúusable‚Äù y m√°s
corto:
limpieza: quitar saltos, dobles espacios, encabezados repetidos
recorte: limitar longitud por nota (ej. 2‚Äì4k chars)
selecci√≥n: quedarte con notas ‚Äúm√©dicas‚Äù vs administrativas
deduplicaci√≥n: muchas evoluciones repiten lo mismo; usa hash por texto
normalizado
Esto se hace bien con:
REGEXP_REPLACE (con moderaci√≥n)
SUBSTR
STANDARD_HASH
filtros por tipo_nota , servicio , autor_rol
Ganancia: reduces volumen y tokens antes del LLM.

3) Agregaci√≥n por d√≠a en SQL (no en la app)
Para cada id_atencion + dia_num :
agrupar evoluciones por tipo
ordenar cronol√≥gicamente
condensar a 3‚Äì8 ‚Äúeventos‚Äù del d√≠a (ver reglas)
Herramientas:
JSON_ARRAYAGG con ORDER BY
LISTAGG (si no quieres JSON)
anal√≠ticas para priorizar (ej. √∫ltima evoluci√≥n m√©dica del d√≠a)
Ganancia: 1 query por d√≠a (batch nocturno) en vez de N queries al alta.
Qu√© optimizar en Oracle (lo que m√°s pega)
A) √çndices (para evoluciones)
Como consultas por id_atencion + dia_num y ordenas por fecha/hora:
√çndice compuesto recomendado (evoluciones):
(id_atencion, dia_num, fecha_hora)
y si filtras por tipo:
(id_atencion, dia_num, tipo_nota, fecha_hora)
Ganancia: Oracle encuentra el d√≠a sin leer otros d√≠as.
B) Particionamiento (si el volumen es grande)
Si evoluciones es enorme y crece diario, particiona por fecha (mensual) y subpartici√≥n
por cl√≠nica/sucursal si aplica.
Ganancia: pruning + menos I/O.
C) Batch diario: ‚Äúsolo si cambi√≥‚Äù
Para no recalcular el d√≠a si nadie escribi√≥ nada:
calculas hash_fuente del conjunto de evoluciones del d√≠a
si el hash no cambia, no regeneras payload_json
Esto reduce CPU nocturna y estabiliza tiempos.
Reglas de ‚Äúresumen del d√≠a‚Äù (lo que debes computar)
Las evoluciones diarias se deben convertir a eventos objetivos; no un copy/paste.
Ejemplo de eventos del d√≠a (estructura):
C√≥mo decidir ‚Äúqu√© entra‚Äù:
cambios (inicio/suspensi√≥n/ajuste)
complicaciones
hitos (UCI, cirug√≠a, transfusi√≥n, VM, hemodi√°lisis)
respuesta (mejora/empeora/estable)
no repetir ‚Äúsin novedades‚Äù 20 veces
Esto lo puedes hacer con reglas SQL simples + diccionario de t√©rminos (tablas de
mapeo).
Flujo final al alta (ultra r√°pido)
Al momento de generar epicrisis:
json
{
"dia": 3,
"hitos": ["ingreso a UCI", "inicio VM"],
"clinico": [
"persistencia de fiebre",
"mejora de saturaci√≥n con O2"
],
"tratamientos": [
{"accion":"inicia","item":"piperacilina/tazobactam EV"},
{"accion":"ajusta","item":"O2 3L -> 2L"}
],
"procedimientos": ["TAC t√≥rax"],
"alertas": ["hipotensi√≥n transitoria (resuelta)"]
}
C√≥mo decidir ‚Äúqu√© entra‚Äù:
cambios (inicio/suspensi√≥n/ajuste)
complicaciones
hitos (UCI, cirug√≠a, transfusi√≥n, VM, hemodi√°lisis)
respuesta (mejora/empeora/estable)
no repetir ‚Äúsin novedades‚Äù 20 veces
Esto lo puedes hacer con reglas SQL simples + diccionario de t√©rminos (tablas de
mapeo).

Flujo final al alta (ultra r√°pido)
Al momento de generar epicrisis:

1. Oracle trae:
datos fijos de ingreso (d√≠a 1)
diagn√≥sticos finales (egreso)
indicaciones de alta (√≥rdenes/receta)
todos los payload_json de ATENCION_DIA_RESUMEN (N filas)
2. La app hace solo:
concatenar los eventos por d√≠a
RAG r√°pido (si quieres citar evidencia por d√≠a)
LLM genera texto final
Tiempo DB t√≠pico: milisegundos a decenas de ms (N d√≠as = N filas peque√±as).

¬øRAG o no RAG si ya tienes JSON?
Para epicrisis, lo m√°s estable es:
Sin RAG si el JSON ya contiene todo lo necesario (mejor calidad, menos latencia).
Con RAG solo para:
‚Äúcitar evidencia‚Äù (trazabilidad: d√≠a 4, nota tal)
responder preguntas ad-hoc (‚Äú.por qu√© se cambi√≥ antibi√≥tico?‚Äù)
Tu caso principal (alta) ‚Üí JSON estructurado + generaci√≥n.
Dise√±o recomendado (con tu alternativa diaria)
Opci√≥n √≥ptima: Daily Delta + Stitch
Proceso nocturno: genera/actualiza resumen del d√≠a D (solo si cambi√≥)
Al alta: junta d√≠a 1..N ya listos + a√±ade ‚Äú√∫ltimas 24h‚Äù si faltara algo
Esto minimiza:
lecturas
CPU
variabilidad de tiempos
tokens para el LLM

Siguiente paso pr√°ctico
Si me pegas (aunque sea anonimizado) el esquema de la tabla de evoluciones
(columnas claves) y c√≥mo identificas tipo_nota/servicio , te devuelvo:
DDL de ATENCION_DIA_RESUMEN
SQL para generar payload_json por d√≠a con dedupe + orden + recorte
estrategia de hash para ‚Äúsolo si cambi√≥‚Äù
√≠ndices exactos y por qu√© (en tu modelo de claves)

Tienes toda la raz√≥n: aunque tengas el JSON perfecto, a√∫n falta ‚Äúredactar‚Äù. La
diferencia es:
RAG = c√≥mo recuperas evidencia desde muchos textos/documentos.
LLM / NLG = c√≥mo conviertes datos estructurados en narrativa.
Si ya tienes un JSON cl√≠nico completo, entonces no necesitas RAG para el alta (porque
no hay ‚Äúb√∫squeda‚Äù); pero s√≠ necesitas un generador de lenguaje‚Ä¶ y eso puede ser:
1) Con LLM (recomendado en cl√≠nica)
Usas el JSON como ‚Äúfuente √∫nica de verdad‚Äù y el LLM solo redacta.
Ventajas:
lenguaje natural fluido
coherencia global (conecta d√≠as, tratamientos, evoluci√≥n)
menos mantenimiento que plantillas complejas
Riesgos (controlables):
puede ‚Äúinventar‚Äù si el prompt no es estricto
Soluci√≥n: constrain prompt + validaci√≥n (abajo te dejo c√≥mo).
Esto se llama: ‚Äúdata-to-text generation‚Äù (NLG) y es el patr√≥n t√≠pico.
2) Sin LLM: plantillas deterministas (posible, pero m√°s r√≠gido)
S√≠ se puede. Hay 2 enfoques:
A) Plantillas por secciones (NLG basada en reglas)
Construyes frases ‚Äúparametrizadas‚Äù:
‚ÄúPaciente {sexo} de {edad} ingresa por {motivo} con diagn√≥stico de ingreso
{dx_ingreso}‚Ä¶‚Äù
‚ÄúDurante la hospitalizaci√≥n se realiz√≥ {procedimientos}‚Ä¶‚Äù
‚ÄúEvolucion√≥ {favorable/estable/t√≥rpida} con {hitos}‚Ä¶‚Äù
‚ÄúAl alta: {dx_egreso}. Se indica {indicaciones}‚Ä¶‚Äù
Esto funciona muy bien si:
tu hospital tiene formatos est√°ndar
los datos estructurados est√°n completos (meds, dx, procedimientos)
aceptas estilo algo ‚Äúrob√≥tico‚Äù
Ventajas: 100% determinista, cero alucinaci√≥n, r√°pido.
Desventajas: mantener reglas es caro; casos complejos se vuelven dif√≠ciles.
B) Micro-frases + motor de agregaci√≥n
En vez de un p√°rrafo largo, armas ‚Äúmicro-oraciones‚Äù que luego concatenas con reglas:
orden temporal
evitar repeticiones
conectores (‚Äúposteriormente‚Äù, ‚Äúen la evoluci√≥n‚Äù, ‚Äúal egreso‚Äù)
Es m√°s natural que A, pero igual requiere reglas y pruebas.
Recomendaci√≥n pr√°ctica para cl√≠nica: ‚ÄúLLM acotado +
validaci√≥n‚Äù
Si te preocupa depender de un LLM, la soluci√≥n madura es:
1) JSON estructurado = fuente √∫nica
El LLM NO ve notas crudas (o solo si pides evidencia).
2) Prompt ‚Äúno inventar‚Äù
Le dices expl√≠citamente:
‚ÄúUsa solo estos datos.‚Äù
‚ÄúSi falta algo, escribe ‚ÄòNo consignado‚Äô.‚Äù
‚ÄúNo agregues diagn√≥sticos, procedimientos ni f√°rmacos que no est√©n en el JSON.‚Äù
3) Validaci√≥n autom√°tica post-generaci√≥n
Despu√©s del texto, pasas un validador r√°pido (reglas/regex) para asegurar:
que todos los medicamentos mencionados existen en indicaciones_alta
que el dx egreso mencionado est√° en diagnostico_egreso
que no aparecen f√°rmacos ‚Äúnuevos‚Äù (lista blanca)
Si falla, regeneras con un prompt que diga:
‚ÄúCorregir: solo puedes usar esta lista de f√°rmacos: ‚Ä¶‚Äù
Esto reduce al m√≠nimo el riesgo cl√≠nico.
Entonces, ¬øsin LLM se puede?
S√≠. Pero en la pr√°ctica:
Si quieres lenguaje natural de verdad + cubrir casos variados ‚Üí LLM peque√±o
local gana.
Si quieres cero riesgo y formato fijo ‚Üí plantillas.
En hospitales, muchas veces se hace un h√≠brido:
‚úÖ plantilla para estructura + LLM solo para ‚Äúevoluci√≥n cl√≠nica‚Äù (lo m√°s narrativo)

Qu√© har√≠a en tu proyecto (√≥ptimo)
Opci√≥n A (calidad + seguridad + velocidad):
1. Oracle produce JSON completo y ‚Äúlimpio‚Äù
2. LLM local redacta con prompt acotado
3. validador asegura no-invenci√≥n
4. firma/versionado
Opci√≥n B (m√°xima determinaci√≥n):
1. Oracle produce JSON
2. generador por plantillas (sin LLM)
3. (opcional) corrector ortogr√°fico/estilo no cl√≠nico local
Si me dices qu√© tan ‚Äúlibre‚Äù debe ser el texto (muy humano vs formato r√≠gido), te
propongo:
un template real de epicrisis Chile
o un prompt + validador listo para producci√≥n (con listas blancas de
dx/meds/proc).

Respuesta:
prompt + validador listo para producci√≥n (con listas
blancas de dx/meds/proc).

Aqu√≠ tienes un prompt de producci√≥n (acotado, anti-invenci√≥n) + un validador con
listas blancas (dx/meds/proc) pensado para que puedas correrlo local y repetir
generaci√≥n si detecta ‚Äúalucinaciones‚Äù.


1) Contrato de entrada (JSON can√≥nico recomendado)
Idealmente cada elemento viene con c√≥digo + nombre (para validar por c√≥digo y
permitir sin√≥nimos):
json


{
  "id_atencion": 1416169,
  "paciente": {
    "sexo": "F",
    "edad": 68
  },
  "atencion": {
    "id": "1416169",
    "fecha_ingreso": "2025-12-15",
    "fecha_alta": "2025-12-26"
  },
  "motivo_ingreso": "Post operatorio cirugia de Miles por cancer de recto",
  "antecedentes": {
    "medicos": [
      "HTA",
      "Cardiopatia hipertensiva",
      "FA paroxistica",
      "Enfermedad hepatica cronica con hipertension portal"
    ],
    "quirurgicos": [
      "Protesis de cadera derecha por artrosis severa"
    ],
    "alergias": "Sin alergias conocidas"
  },
  "diagnostico_ingreso": [
    { "codigo": "C20", "nombre": "Tumor maligno del recto" },
    { "codigo": "K74.6", "nombre": "Cirrosis hepatica, otra y la no especificada" },
    { "codigo": "J90", "nombre": "Derrame pleural no clasificado en otra parte" }
  ],
  "procedimientos": [
    { "codigo": "48.52", "nombre": "Cirugia de Miles (reseccion abdominoperineal)" },
    { "codigo": "34.04", "nombre": "Pleurostomia 24 FR" },
    { "codigo": "87.41", "nombre": "TAC de torax" },
    { "codigo": "87.43", "nombre": "TAC de abdomen y pelvis" },
    { "codigo": "86.22", "nombre": "VAC perineal (curacion con presion negativa)" }
  ],
  "tratamientos_intrahosp": [
    { "codigo": "ATC:J01CR05", "nombre": "Piperacilina/Tazobactam", "via": "EV", "inicio": "2025-12-15", "fin": "2025-12-19" },
    { "codigo": "ATC:J01DH02", "nombre": "Meropenem 1g c/8h", "via": "EV", "inicio": "2025-12-19", "fin": "2025-12-26" },
    { "codigo": "ATC:J01XA01", "nombre": "Ceftriaxona", "via": "EV", "inicio": "2025-12-15", "fin": "2025-12-17" },
    { "codigo": "ATC:J01XD01", "nombre": "Metronidazol", "via": "EV", "inicio": "2025-12-15", "fin": "2025-12-17" }
  ],
  "evolucion_resumen": [
    {
      "dia": 1,
      "texto": "TORAX- PLEUROSTOMIA PACIENTE POST OP DE CIRUGIA DE MILES. DERRAME PLEURAL BILATERAL, A DERECHA MODERADO A SEVERO ACTUALMENTE EN TAC DE TORAX DE CONTROL. SE INSTALA PLEUROSTOMIA 24 FR, LA QUE SE FIJA EN 14 CM, DANDO SALIDA A 1000 CC DE CONTENIDO SERORO OSCURO. SE CLAMPEA POR TOS. SE TOMAN MUESTRAS PARA ESTUDIO DE LIQUIDO: CITOQUIMICO, PH, CULTIVO. SE SUGIERE: - EVACUAR 500 CC CADA 1HR HASTA DEJAR DESCLAMPEADO. - MANANA ASPIRATIVO A PARTIR DE LAS 8 AM. - CONTROL DE RX MANANA - KNT R Y M + TRIFLO"
    },
    {
      "dia": 2,
      "texto": "TORAX ESTABLE, PLEUROSTOMIA 1340 CC SEROHEMATICO. RADIOGRAFIA CON EXPANSION PULMONAR COMPLETA. EX: MP + DISMINUIDO A BASE DERECHA ESTUDIO INICIAL DE LIQUIDO PLEURAL, COMPATIBLE CON EXUDADO. SE SUGIERE: MANTENER ASPIRATIVO KNT R Y M + TRIFLO SEGUIMIENTO DE PLEUROSTOMIA"
    },
    {
      "dia": 3,
      "texto": "TORAX PACIENTE ESTABLE, SIN DIFICULTAD RESPIRATORIA, SAT 96-98 CON FIO2 AMBIENTAL. PLEUROSTOMIA 800 CC SEROSO ULTIMAS 12 HRS. ULTIMO TAC CON SIGNOS DE DHC E HIPERTENSION PORTAL, ASOCIADO A ASCITIS EN ESTE CONTEXTO, ESTO PUEDE ESTAR FAVORECIENDO ALTO DEBITO DE DRENAJE PLEURAL. EX: MP CONSERVADO A DERECHA, LEVEMENTE DISMINUIDO A IZQUIERDA. SE SUGIERE: POR AHORA DRENAJE NO ASPIRATIVO CAMBIO DE ACQUEASEAL DE SER NECESARIO CONTROL DE RX MANANA SE SUGIERE EVALUAR COMPONENTE DE DHC Y MANEJO A FIN DE DISMINUIR DEBITO DE DRENAJE TORACICO"
    },
    {
      "dia": 4,
      "texto": "TORAX ESTABLE RESPIRATORIO 400 CC EN 12 HRS. PROBABLEMENTE EN CONTEXTO DE ASCITIS Y SIGNOS DE DHC + HIPERTENSION PORTAL EX: MP + CONSERVADO SRA PLAN: MANTENER SEP NO ASPIRATIVO KN T R Y M POR 2 VECES DIA CONTROL DE RX HOY (ORDEN REALIZADA) SE SUGIERE EVALUACION POR MEDICINA INTERNA/GASTRO | EN SIMILARES CONDICIONES. CON NAUSEAS"
    },
    {
      "dia": 5,
      "texto": "TORAX ESTABLE, RADIOGRAFIA DE AYER CON EXPANSION COMPLETA, SIN DIFICULTAD RESPIRATORIA. ACQUASEAL AL TOPE. SE INDICA CAMBIO INMEDIATO. EX: MP + CONSERVADO A DERECHA PLEUROSTOMIA 1000 CC EN 24 HRS SE SUGIERE: DEBE SER EVALUADA DEL PUNTO DE VISTA DE ASCITIS MANTENER KNT 2 VECES AL DIA + TRIFLO OBSERVAR DEBITOS EN FORMA ESTRICTA MANTENER NO ASPIRATIVO SEGUIMIENTO POR TORAX | Medicina interna Enterado. HTA, cirugia de cancer de colon hace 1 mes aprox. TAC con hallazgos compatibles con DHC. Desde ayer con nauseas y vomitos alimentarios. Ex fisico: impresiona icterica, abdomen distendido, timpanico. plan - ajusto terapia - exs: p. hepaticas - Evaluacion por Gastro - Reevaluacion SOS. | 68 anios, sin alergias conocidas. AM: HTA, cardiopatia hipertensiva, FA paroxistica, enfermedad hepatica cronica con HTP. Cx: protesis de cadera derecha (por artrosis severa) Mascotas: gatos En el marco de un Ca de recto que progreso a pesar de QMT, se hospitalizo para Cx de miles. Evoluciono en el post op con colecciones perineal y en excavacion pelviana. Ya esta en sala, se alimenta poco, con nauseas y vomitos persistentes. Parametros inflamatorios estacionarios (PCR 15), GB: 12.770, VHS: 9 se sugiere: 1.- Suspender piperacilina-tazobactam 2.- Meropenem 1 gr cada 8 IV 3.- TAC de abdomen y pelvis c/c 4.- Considerar traslado a sala de mayor complejidad atte AGUAYO"
    },
    {
      "dia": 6,
      "texto": "TORAX ESTABLE, TAC DE TORAX DE CONTROL CON MINIMO DERRAME RESIDUAL DERECHO Y LEVE IZQUIERDO. EXPANSION ADECUADA. ACTUALMENTE 120 CC EN 12 HRS PLAN: MANTENER NO ASPIRATIVO KNT + TRIFLO SE REEVALUARA RETIRO SEGUN DEBITO"
    },
    {
      "dia": 7,
      "texto": "TORAX ESTABLE DEL PUNTO DE VISTA VENTILATORIO DISMINUCION DEL DEBITO DIARIO. 300 CC EN 24 HRS. ACTUALMENTE EN MANEJO DE LIQUIDO ASCITICO, CON BUENA RESPUESTA SE SUGIERE: MANTENER NO ASPIRATIVO RETIRO CON DEBITO CERCANO A 150 CC KN T R Y M"
    },
    {
      "dia": 8,
      "texto": "TORAX ESTABLE, 550 CC EN 24 HRS. SIN COMPROMISO VENTILATORIO. EN ESPERA DE DISMINUCION DE DEBITO PARA RETIRO DE SEP. POR AHORA SIN CAMBIOS"
    },
    {
      "dia": 9,
      "texto": "TORAX ESTABLE, HOY 390 CC DE DEBITO. EX: MP + CONSERVADO PLAN: MANTENER KNT MANTENER NO ASPIRATIVO EVENTUAL RETIRO MANANA SEGUN DEBITO"
    },
    {
      "dia": 10,
      "texto": "TORAX ESTABLE 310 CC EN 24 HRS (PERO 50 CC MAS EN LA BAJA POST MEDICION) DE TODAS FORMAS CON DEBITO A LA BAJA, LENTO SE CONVERSA CON PACIENTE, SE DECIDE MANTENER PLAN: KNT R Y M MANTENER NO ASPIRATIVO MANTENER MANEJO DE ASCITIS (EL CUAL HA SIDO EFECTIVO)"
    },
    {
      "dia": 12,
      "texto": "TORAX ESTABLE, DEBITO DE 50 CC EN 24 HRS, POR LO QUE SE DECIDE RETIRO. PROCEDIMIENTO SIN INCIDENTES. PLAN: MANTENER CON KNT CAMBIO DE APOSITO SOS RETIRO DE PUNTOS EN 5-7 DIAS REEVALUACION POR CIRUGIA DE TORAX SOS"
    }
  ],
  "laboratorios_resumen": [
    {
      "prueba": "Hemoglobina en sangre total",
      "unidad": "g/dL",
      "ingreso": {
        "valor": 7.8,
        "fecha": "2025-12-25T07:11:09",
        "rango_inferior": 12.3,
        "rango_superior": 15.3,
        "estado": "bajo"
      },
      "periodo": {
        "min": 7.8,
        "max": 7.8
      }
    },
    {
      "prueba": "Hematocrito",
      "unidad": "%",
      "ingreso": {
        "valor": 23.7,
        "fecha": "2025-12-25T07:11:09",
        "rango_inferior": 35,
        "rango_superior": 47,
        "estado": "bajo"
      },
      "periodo": {
        "min": 23.7,
        "max": 23.7
      }
    },
    {
      "prueba": "Recuento de leucocitos (absoluto)",
      "unidad": "x10^9/L",
      "ingreso": {
        "valor": 12.62,
        "fecha": "2025-12-25T07:11:09",
        "rango_inferior": 4.4,
        "rango_superior": 11.3,
        "estado": "alto"
      },
      "periodo": {
        "min": 12.62,
        "max": 12.62
      }
    },
    {
      "prueba": "Proteina C reactiva",
      "unidad": "mg/dL",
      "ingreso": {
        "valor": 8.79,
        "fecha": "2025-12-25T07:11:11",
        "rango_inferior": 0,
        "rango_superior": 0.49,
        "estado": "alto"
      },
      "periodo": {
        "min": 8.79,
        "max": 8.79
      }
    },
    {
      "prueba": "Albumina en sangre",
      "unidad": "g/dL",
      "ingreso": {
        "valor": 2.82,
        "fecha": "2025-12-25T07:11:10",
        "rango_inferior": 3.5,
        "rango_superior": 5.2,
        "estado": "bajo"
      },
      "periodo": {
        "min": 2.82,
        "max": 2.82
      }
    },
    {
      "prueba": "Potasio plasmatico",
      "unidad": "mmol/L",
      "ingreso": {
        "valor": 3.3,
        "fecha": "2025-12-25T07:11:10",
        "rango_inferior": 3.5,
        "rango_superior": 5.1,
        "estado": "bajo"
      },
      "periodo": {
        "min": 3.3,
        "max": 3.3
      }
    },
    {
      "prueba": "Calcio en sangre",
      "unidad": "mg/dL",
      "ingreso": {
        "valor": 7.6,
        "fecha": "2025-12-25T07:11:10",
        "rango_inferior": 8.8,
        "rango_superior": 10.2,
        "estado": "bajo"
      },
      "periodo": {
        "min": 7.6,
        "max": 7.6
      }
    },
    {
      "prueba": "Creatinina en sangre",
      "unidad": "mg/dL",
      "ingreso": {
        "valor": 0.63,
        "fecha": "2025-12-25T07:11:10",
        "rango_inferior": 0.5,
        "rango_superior": 0.9,
        "estado": "normal"
      },
      "periodo": {
        "min": 0.63,
        "max": 0.63
      }
    },
    {
      "prueba": "Sodio plasmatico",
      "unidad": "mmol/L",
      "ingreso": {
        "valor": 143.1,
        "fecha": "2025-12-25T07:11:10",
        "rango_inferior": 136,
        "rango_superior": 145,
        "estado": "normal"
      },
      "periodo": {
        "min": 143.1,
        "max": 143.1
      }
    },
    {
      "prueba": "Recuento de plaquetas (absoluto)",
      "unidad": "x10^3/uL",
      "ingreso": {
        "valor": 170,
        "fecha": "2025-12-25T07:11:09",
        "rango_inferior": 150,
        "rango_superior": 450,
        "estado": "normal"
      },
      "periodo": {
        "min": 170,
        "max": 170
      }
    }
  ],
  "diagnostico_egreso": [
    { "codigo": "C20", "nombre": "Tumor maligno del recto - Post operatorio cirugia de Miles" },
    { "codigo": "J90", "nombre": "Derrame pleural bilateral resuelto" },
    { "codigo": "K74.6", "nombre": "Enfermedad hepatica cronica con hipertension portal" },
    { "codigo": "K65.0", "nombre": "Coleccion pelviana post quirurgica en tratamiento" }
  ],
  "indicaciones_alta": {
    "medicamentos": [
      { "codigo": "ATC:J01DH02", "nombre": "Meropenem", "dosis": "1g", "via": "EV", "frecuencia": "cada 8 horas", "duracion": "Completar esquema segun infectologia" }
    ],
    "controles": [
      "Control con cirugia de torax en caso de sintomas respiratorios",
      "Control con cirugia digestiva para seguimiento de colostomia",
      "Control con infectologia para ajuste de antibioticos",
      "Retiro de puntos de pleurostomia en 5-7 dias"
    ],
    "cuidados": [
      "Curacion de herida perineal con VAC segun indicacion",
      "Curacion de sitio de pleurostomia",
      "Cuidados de colostomia",
      "Kinesioterapia respiratoria y motora",
      "Ejercicios con Triflo"
    ],
    "signos_alarma": [
      "Fiebre mayor a 38C",
      "Disnea o dificultad respiratoria",
      "Dolor toracico",
      "Aumento de volumen o secrecion por heridas",
      "Nauseas o vomitos persistentes",
      "Ictericia progresiva"
    ]
  }
}



Clave para la validaci√≥n: que dx/meds/proc tengan un identificador estable ( codigo ).
Si hoy solo tienes texto, igual se puede, pero la validaci√≥n ser√° m√°s ‚Äúheur√≠stica‚Äù.

2) Prompt listo para producci√≥n (acotado y auditable)
SYSTEM (fijo)

txt
Eres un asistente cl√≠nico que redacta informes de alta hospitalaria (epicr
REGLAS ESTRICTAS:
1) Usa EXCLUSIVAMENTE los datos entregados en el JSON. No inventes diagn√≥s
2) Si falta un dato necesario, escribe literalmente: "No consignado".
3) No incluyas informaci√≥n personal identificable adicional a sexo y edad
4) Redacta en 1 solo p√°rrafo, formal, claro y conciso.
5) No enumeres valores de laboratorio salvo que el JSON incluya n√∫meros; s
6) No menciones marcas comerciales; usa nombres gen√©ricos tal como aparece
7) No agregues recomendaciones nuevas: solo las indicaciones de alta del J
SALIDA: Un √∫nico p√°rrafo (sin vi√±etas, sin t√≠tulos).

USER (variable)
txt
Genera una epicrisis (informe de alta) en un solo p√°rrafo con esta estruct
- Motivo y diagn√≥stico de ingreso
- Procedimientos y tratamientos relevantes durante hospitalizaci√≥n
- Evoluci√≥n cl√≠nica resumida (por d√≠as si corresponde, sin repetir)
- Diagn√≥stico(s) de egreso
- Indicaciones post-alta: medicamentos (con dosis/v√≠a/frecuencia/duraci√≥n)

JSON CL√çNICO:
{{JSON_CLINICO}}

Por qu√© funciona: el LLM queda ‚Äúencerrado‚Äù en un √∫nico documento fuente (tu JSON),
por lo que ya no necesitas RAG para el alta.

3) Validador con listas blancas (dx/meds/proc)
Estrategia de validaci√≥n (robusta)
1. Construyes listas blancas desde el JSON:
dxWhitelist : set de c√≥digos + nombres normalizados
procWhitelist
medWhitelist (de alta y/o intrahospital seg√∫n lo que permitas mencionar)
2. Del texto generado, detectas menciones:
Primero por c√≥digos (si obligas al modelo a incluirlos, m√°s f√°cil)
Si no incluyes c√≥digos, haces matching por nombres normalizados y sin√≥nimos
controlados
3. Si detectas una menci√≥n que no est√° en whitelist ‚Üí falla y se regenera con un
prompt correctivo.
4) C√≥digo de validador (TypeScript/JS) usable
JSON CL√çNICO:
{{JSON_CLINICO}}
Este validador es pragm√°tico: normaliza, tokeniza, busca menciones por ‚Äúfrases‚Äù y
compara contra whitelist. Para producci√≥n cl√≠nica, recomiendo adem√°s mantener una
tabla de sin√≥nimos (ej. ‚ÄúTAC‚Äù ~ ‚ÄúTomograf√≠a computada‚Äù).
ts

type Item = { codigo?: string; nombre: string };
type Med = { codigo?: string; nombre: string; dosis?: string; via?: string; frecuencia?: string; duracion?: string };

function normalize(s: string): string {
  return s
    .toLowerCase()
    .normalize("NFD").replace(/\p{Diacritic}/gu, "") // quita tildes
    .replace(/[^a-z0-9\s\/\-]/g, " ")               // limpia s√≠mbolos
    .replace(/\s+/g, " ")
    .trim();
}

function makeWhitelist(items: Item[]): { codes: Set<string>; names: Set<string> } {
  const codes = new Set<string>();
  const names = new Set<string>();
  for (const it of items || []) {
    if (it.codigo) codes.add(normalize(it.codigo));
    names.add(normalize(it.nombre));
  }
  return { codes, names };
}

// extrae frases candidatas: n-grams simples (2 a 6 palabras)
function extractNgrams(textNorm: string, minN = 2, maxN = 6): Set<string> {
  const words = textNorm.split(" ").filter(Boolean);
  const out = new Set<string>();
  for (let n = minN; n <= maxN; n++) {
    for (let i = 0; i + n <= words.length; i++) {
      out.add(words.slice(i, i + n).join(" "));
    }
  }
  return out;
}

type ValidationResult = {
  ok: boolean;
  violations: {
    type: "dx" | "proc" | "med";
    mention: string;
    reason: string;
  }[];
};

type ClinicalJson = {
  diagnostico_ingreso?: Item[];
  diagnostico_egreso?: Item[];
  procedimientos?: Item[];
  tratamientos_intrahosp?: Med[];
  indicaciones_alta?: { medicamentos?: Med[] };
};

export function validateEpicrisis(text: string, data: ClinicalJson): ValidationResult {
  const textNorm = normalize(text);
  const grams = extractNgrams(textNorm);

  // whitelist: permite mencionar dx ingreso + egreso
  const dxWL = makeWhitelist([...(data.diagnostico_ingreso || []), ...(data.diagnostico_egreso || [])]);
  const procWL = makeWhitelist(data.procedimientos || []);
  // meds permitidos: alta + (opcional) intrahosp si quieres que aparezcan en narrativa
  const medWL = makeWhitelist([
    ...((data.indicaciones_alta?.medicamentos || []).map(m => ({ codigo: m.codigo, nombre: m.nombre }))),
    ...((data.tratamientos_intrahosp || []).map(m => ({ codigo: m.codigo, nombre: m.nombre }))),
  ]);

  // diccionario de sin√≥nimos CONTROLADOS (puedes expandirlo)
  const synonyms: Record<string, string[]> = {
    "tac": ["tomografia computada", "tc"],
    "uci": ["unidad de cuidados intensivos"],
  };

  function allowedMention(mention: string, wl: { codes: Set<string>; names: Set<string> }): boolean {
    const m = normalize(mention);
    if (wl.codes.has(m)) return true;
    if (wl.names.has(m)) return true;
    // aplica sin√≥nimos hacia nombres permitidos
    for (const [key, syns] of Object.entries(synonyms)) {
      if (m === key || syns.includes(m)) {
        // si el ‚Äúconcepto‚Äù existe en whitelist por su forma can√≥nica, lo damos por v√°lido
        if (wl.names.has(key)) return true;
        for (const s of syns) if (wl.names.has(s)) return true;
      }
    }
    return false;
  }

  // Heur√≠stica: si aparece una frase que parece ‚Äúmedicamento/procedimiento/dx‚Äù pero no est√° en WL => viola.
  // Para bajar falsos positivos, validamos solo contra candidatos que coinciden ‚Äúparcialmente‚Äù con t√©rminos m√©dicos comunes.
  const medicalTriggers = [
    "mg", "ev", "vo", "im", "sc", "cada", "hrs", "horas", "dias",
    "diagnostico", "neumonia", "insuficiencia", "fractura", "sepsis",
    "cirugia", "procedimiento", "tac", "rx", "ecg", "endoscopia",
    "antibiotico", "analgesia"
  ];

  const violations: ValidationResult["violations"] = [];

  function checkCategory(type: "dx" | "proc" | "med", wl: { codes: Set<string>; names: Set<string> }) {
    for (const g of grams) {
      // filtra por ‚Äúparece cl√≠nico‚Äù
      const hasTrigger = medicalTriggers.some(t => g.includes(t));
      if (!hasTrigger) continue;

      // si g es exactamente uno de los nombres permitidos, ok
      if (wl.names.has(g)) continue;

      // si g parece un c√≥digo (CIE10/ATC/etc) y no est√° en codes, marca
      if (/^[a-z]\d{2}(\.\d)?$/i.test(g) || g.startsWith("atc:") || /^[a-z0-9]{3,10}[:\-][a-z0-9]{2,10}$/i.test(g)) {
        if (!wl.codes.has(g)) {
          violations.push({ type, mention: g, reason: "C√≥digo no permitido por whitelist" });
        }
        continue;
      }

      // detecci√≥n ‚Äúsoft‚Äù: si contiene una palabra de un nombre permitido, no lo consideres violaci√≥n.
      // (evita falsos positivos por frases largas tipo ‚Äúse indica azitromicina 500 mg‚Ä¶‚Äù)
      let overlapsAllowed = false;
      for (const name of wl.names) {
        // si la frase contiene el nombre permitido (substring), lo damos por permitido
        if (g.includes(name) && name.length >= 5) { overlapsAllowed = true; break; }
      }
      if (overlapsAllowed) continue;

      // si parece un t√©rmino cl√≠nico pero no match, lo reportamos como ‚Äúposible alucinaci√≥n‚Äù
      // (en producci√≥n puedes hacerlo ‚Äúwarning‚Äù y no bloquear si no quieres ser tan estricto)
      // aqu√≠ lo hacemos estricto
      violations.push({ type, mention: g, reason: "Menci√≥n cl√≠nica no encontrada en whitelist" });
    }
  }

  // chequeos separados (puedes ajustar triggers por categor√≠a)
  checkCategory("dx", dxWL);
  checkCategory("proc", procWL);
  checkCategory("med", medWL);

  // dedupe violaciones
  const seen = new Set<string>();
  const uniq = violations.filter(v => {
    const k = `${v.type}|${v.mention}`;
    if (seen.has(k)) return false;
    seen.add(k);
    return true;
  });

  return { ok: uniq.length === 0, violations: uniq };
}

Qu√© hace este validador
Si el texto menciona algo con pinta cl√≠nica (por triggers) y no coincide con whitelist
‚Üí bloquea.
Evita falsos positivos cuando una frase larga contiene un nombre permitido
(substring).
Puedes ajustar el modo estricto (bloquear) vs ‚Äúwarning‚Äù.

5) Prompt de ‚Äúcorrecci√≥n‚Äù para regenerar cuando falla
Cuando validateEpicrisis().ok === false , regeneras con este USER adicional:

txt
Tu texto anterior contiene menciones NO permitidas (alucinaciones) o fuera
Debes reescribir el informe de alta en 1 solo p√°rrafo CUMPLIENDO:
- Solo puedes mencionar diagn√≥sticos de esta lista: {{DX_LISTA}}
- Solo puedes mencionar procedimientos de esta lista: {{PROC_LISTA}}
- Solo puedes mencionar medicamentos de esta lista: {{MED_LISTA}}
Si necesitas algo fuera de las listas, escribe "No consignado".
Reescribe completo el informe usando el mismo JSON.
JSON CL√çNICO:
{{JSON_CLINICO}}

Donde DX_LISTA/PROC_LISTA/MED_LISTA son los nombres (y/o c√≥digos) extra√≠dos del
JSON.

6) Recomendaci√≥n clave para que esto quede ‚Äúa prueba de cl√≠nica‚Äù
Para bajar falsos positivos y subir control:
En el prompt, exige que el modelo incluya c√≥digos entre par√©ntesis:
‚ÄúNeumon√≠a bacteriana (J15.9)‚Äù
‚ÄúAzitromicina (ATC:J01FA10)‚Äù
As√≠ la validaci√≥n se vuelve casi perfecta porque verificas c√≥digos exactos y no dependes
de texto.
Si me pegas un ejemplo real (anonimizado) del JSON que ya construyes, te adapto:
lista blanca exacta (qu√© permites mencionar en narrativa vs solo en indicaciones),
reglas de ‚Äútratamientos intrahosp s√≠/no‚Äù,
y un set de triggers/sin√≥nimos cl√≠nicos Chile (TAC/TC, UCI/UPC, EV/IV, etc.) para
reducir falsos positivos.


